# Лабораторные работы по Python

## Файлы с кодом
- [Лаба-1 в1.py](https://github.com/gulidovalera/Maksimuk_Uladzislau_Python_Labs/blob/Lab_1/Lab%201.py) - Лабораторная работа 1
- [лаба2 (1).py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/лаба2%20(1).py) - Лабораторная работа 2
- [В3задание2(2).py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/%23В3задание2(2).py), [В1задание1(2).py](https://github.com/gulidovalera/laba/blob/лаба-1/В1задание1(2).py) - Лабораторная работа 3
- [лаба4_В3 биопитон с окном для файла.py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/лаба4_В3%20биопитон%20с%20окном%20для%20файла.py) - Лабораторная работа 4

---

## Лабораторная работа 1: "Подсчёт точечных мутаций методом Хэмминга для триплетов ДНК"

### Цель работы
Исследование точечных мутаций в последовательностях ДНК путём вычисления расстояния Хэмминга между триплетами (группами из трёх нуклеотидов) двух гомологичных цепей ДНК. Разработка программных реализаций на Python для решения данной задачи.

## Задачи
1. Реализовать функцию для вычисления расстояния Хэмминга между триплетами двух последовательностей ДНК
2. Создать объектно-ориентированную версию программы с использованием класса
3. Обеспечить корректную обработку входных данных:
  - Проверка равенства длин последовательностей
  - Валидация допустимых символов (A, T, G, C)
4. Протестировать программу на примере из условия задачи

### Инструменты и алгоритмы
 Язык программирования: Python.
 Стандартные библиотеки Python (без дополнительных зависимостей)
 Функциональная реализация:
 - Разбиение последовательностей на триплеты с шагом 3
 - Поэлементное сравнение нуклеотидов в соответствующих триплетах
 - Подсчёт количества несовпадений
Объектно-ориентированная реализация:
 - Класс HammingTripletCalculator, инкапсулирующий:
  - Хранение последовательностей
  - Ввод данных
  - Вычисление расстояния Хэмминга
  - Использование метода zip для попарного сравнения символов
Структура программы:
 ```python
# Функциональный подход
def hamming_distance_triplets(s, t):
    # ... реализация ...

# Объектно-ориентированный подход
class HammingTripletCalculator:
    def __init__(self): ...
    def input_sequence(self): ...
    def calculate_distance(self): ...
 ```

### Ошибки и исправления
Проблема: Отсутствие проверки длины последовательностей
Симптомы: Неверные результаты при неравных длинах
Решение: Добавить проверку if len(s) != len(t): raise ValueError()

Проблема: Нет валидации входных символов
Симптомы: Возможны ошибки при вводе недопустимых символов
Решение: Добавить проверку символов на принадлежность к {'A', 'T', 'G', 'C'}

Проблема: Неполные триплеты в конце последовательности
Симптомы: Потеря данных при длине не кратной 3
Решение: Обрабатывать остаток как отдельный триплет или требовать длину, кратную 3

Проблема: Чувствительность к регистру
Симптомы: Разные результаты для 'A' и 'a'
Решение: Приводить последовательности к верхнему регистру

### Выводы
Разработаны две реализации алгоритма подсчёта расстояния Хэмминга для триплетов ДНК:
 - Процедурная (функциональная) версия
 - Объектно-ориентированная версия

Программа успешно решает поставленную задачу:
 - Корректно вычисляет количество точечных мутаций
 - Работает с последовательностями длиной до 1000 символов
 - Обрабатывает триплеты как отдельные блоки сравнения

Объектно-ориентированный подход показал следующие преимущества:
 - Лучшая структурированность кода
 - Инкапсуляция данных и методов
 - Возможность легкого расширения функциональности

Практическое применение:
 - Анализ мутаций в кодирующих областях ДНК
 - Сравнение гомологичных последовательностей
 - Исследование эволюционных расстояний между видами

Дальнейшие улучшения могут включать:
 - Визуализацию различий между последовательностями
 - Статистический анализ распределения мутаций
 - Поддержку других типов нуклеиновых кислот (РНК)
 - Расширение для работы с аминокислотными последовательностями

Программа демонстрирует эффективный подход к анализу точечных мутаций и может служить основой для более сложных биоинформатических инструментов.

---

## Лабораторная работа 2: "Анализ мотивов ДНК методом поиска подстрок"

### Цель работы
Разработка программы для поиска всех вхождений заданного мотива (короткой последовательности ДНК) в геномной последовательности с определением точных позиций вхождения и их последующей сортировкой.

### Задачи
1. Реализовать алгоритм поиска подстроки в строке ДНК
2. Обеспечить обработку входных данных:
 - Проверка длины последовательностей
 - Нормализация регистра символов
 - Валидация нуклеотидных последовательностей
3. Реализовать сортировку найденных позиций с использованием алгоритма сортировки слиянием
4. Протестировать программу на примере из условия задачи
   
### Инструменты и алгоритмы
- Язык программирования: Python.
- Стандартные библиотеки Python
####Основные алгоритмы:
Алгоритм поиска подстроки:
 - Последовательный перебор всех возможных подстрок
 - Сравнение с искомым мотивом
 - Сложность O(n*m), где n - длина геномной последовательности, m - длина мотива
Алгоритм сортировки слиянием:
 - Рекурсивное разделение массива
 - Слияние упорядоченных подмассивов
 - Сложность O(n log n)
    ```python
   def find_positions(s, t):  # Поиск позиций
    # ... реализация ...
   def merge_sort(arr):  # Сортировка слиянием
    # ... реализация ...
   def merge(left, right):  # Слияние подмассивов
    # ... реализация ...
    
    ```

### Ошибки и исправления
Проблема: Чувствительность к регистру символов
Решение: Приведение последовательностей к верхнему регистру (s.upper(), t.upper())
Проблема: Некорректная обработка граничных условий

Решение: Добавление проверок:

 ```python
if len(t) == 0 or len(t) > len(s):
    return positions
 ```
Проблема: Избыточная сортировка уже упорядоченных данных
Анализ: Позиции при поиске сохраняются в порядке возрастания
Решение: Можно исключить сортировку или оставить для универс

### Выводы
Разработанная программа успешно решает поставленную задачу поиска мотивов в последовательностях ДНК:
 - Корректно находит все вхождения подстроки
 - Обрабатывает последовательности длиной до 1 кб
 - Обеспечивает вывод результатов в требуемом формате

Реализованы два ключевых алгоритма:
 - Наивный алгоритм поиска подстроки
 - Эффективный алгоритм сортировки слиянием

Обнаруженные проблемы и их решения:
 - Учтена регистрозависимость
 - Добавлены проверки граничных условий
 - Оптимизирован процесс сортировки

Практическое применение:
 - Анализ геномных последовательностей
 - Поиск регуляторных элементов
 - Идентификация повторяющихся участков ДНК

Перспективы развития:
 - Реализация более эффективных алгоритмов поиска (Кнута-Морриса-Пратта)
 - Добавление поддержки неточных совпадений
 - Визуализация результатов поиска
 - Интеграция с биоинформатическими базами данных
---

## Лабораторная работа 3: "Представление данных в Python"

### Цель работы
Освоить методы визуализации данных в Python с использованием библиотеки matplotlib:
1. Построение диаграммы рассеяния для анализа взаимосвязи между признаками и их классификации.
2. Построение графиков временных рядов для изучения динамики изменения данных.

### Задания
## Задание 1. Построение диаграммы рассеяния
1. Загрузить данные (набор Iris).
2. Выбрать два признака для осей X и Y.
3. Визуализировать данные с цветовой дифференциацией по классам.
4. Добавить подписи, легенду и сетку для улучшения читаемости.

## Задание 2. Построение графика временных рядов
1. Загрузить данные (уровень CO₂).
2. Выбрать временной промежуток для анализа.
3. Построить график динамики изменений.
4. Настроить оформление (заголовок, подписи осей, сетку).

### Инструменты
- `matplotlib.pyplot` для визуализации
- `sklearn.datasets` для Iris
- `statsmodels.api` для CO₂

 Библиотеки:
- `matplotlib.pyplot` для визуализации.
- `sklearn.datasets` для загрузки данных Iris.
-  `statsmodels.api` для CO₂
 Алгоритм задание 1:
- Загрузка данных: load_iris().
- Разделение данных по классам: self.y == label.
- Построение scatter-графика: plt.scatter().
- Настройка оформления: plt.xlabel(), plt.legend().

 Алгоритм задание 2:
- Загрузка данных: sm.datasets.co2.load_pandas().
- Фильтрация по временному диапазону: self.co2[start_date:end_date].
- Построение линейного графика: plt.plot().
- Настройка оформления: plt.title(), plt.grid().
  
### Ошибки и исправления
## Задание 1
1. Ошибка: Неверный выбор индексов признаков.
- Пример: Использование индексов 5 и 6 (выход за границы).
- Исправление: Проверка диапазона (0 ≤ index < 4).
2. Ошибка: Наложение подписей точек.
- Пример: Перекрывающиеся метки классов.
- Исправление: Увеличение размера графика (figsize=(12, 8)).
3. Ошибка: Неправильные цвета для классов.
- Пример: Повторение цветов (['red', 'red', 'blue']).
- Исправление: Уникальные цвета для каждого класса.

## Задание 2
1. Ошибка: Неверный формат дат.
- Пример: start_date='1958' (отсутствует месяц и день).
- Исправление: Указание полной даты ('1958-01-01').
2. Ошибка: Пропущенные данные в ряду.
- Пример: Пробелы в данных CO₂.
- Исправление: Интерполяция (self.co2.interpolate()).
3. Ошибка: Слишком плотная сетка дат.
- Пример: Нечитаемые подписи на оси X.
- Исправление: Настройка частоты меток (plt.xticks(rotation=45)).

### Выводы
1. Результаты задания 1:
- Диаграмма рассеяния наглядно показывает кластеры видов ирисов по выбранным признакам.
- Цветовое разделение упрощает интерпретацию классов.
2. Результаты задания 2:
- График временного ряда CO₂ демонстрирует устойчивый рост концентрации за выбранный период.
- Настройка оформления улучшает восприятие динамики.
3. Общие выводы:
- Библиотека matplotlib предоставляет гибкие инструменты для визуализации данных.
- Важно учитывать потенциальные ошибки (формат данных, наложение графиков) для корректного отображения.

---

## Лабораторная работа 4: "Работа с BioPython"

### Цель работы
Обработка биологических данных в формате GenBank:
1. Объединение файлов
2. Анализ GC-состава
3. Трансляция кодирующих областей

### Задачи
## Задание 1. Формирование исходного файла
1. Загрузить по 5 CDS-последовательностей для двух видов с NCBI в формате GenBank.
2. Объединить записи в единый файл средствами BioPython.
3. Проверить, что итоговый файл содержит не менее 10 CDS.

## Задание 2. Анализ GC-составов
1. Прочитать файл GenBank, извлечь последовательности.
2. Вычислить GC-состав для каждой последовательности.
3. Отсортировать последовательности по возрастанию GC-состава.
4. Вывести результаты с указанием ID, описания и значения GC.

## Задание 3. Трансляция
1. Извлечь кодирующие области (CDS) из файла GenBank.
2. Транслировать нуклеотидные последовательности в аминокислотные.
3. Вывести белковые последовательности с указанием исходных CDS.

### Инструменты
## Задание 1
 Библиотеки:
- `Bio.SeqIO` для чтения/записи GenBank-файлов.
 Алгоритм:
- Скачивание данных с NCBI (вручную).
- Объединение файлов через SeqIO.write(records, "output.gb", "genbank").

## Задание 2
 Библиотеки:
- `Bio.SeqIO` для парсинга GenBank.
- `tkinter` для GUI.
 Алгоритм:
- Чтение файла: SeqIO.parse(filename, "genbank").
- Расчет GC-состава:
 ```python
 gc_content = (seq.count("G") + seq.count("C")) / len(seq)
 ```
- Сортировка: sorted(sequences, key=lambda x: x[2]).

## Задание 3
 Библиотеки:
- `Bio.Seq` для трансляции.
 Алгоритм:
- Извлечение CDS из записей GenBank.
- Трансляция: seq.translate(table="стандартный_код").

### Ошибки и исправления
## Задание 1
1. Ошибка: Несовместимость форматов файлов от разных видов.
- Исправление: Проверка и конвертация в единый формат GenBank.
2. Ошибка: Отсутствие CDS в некоторых записях.
- Исправление: Фильтрация записей с if "CDS" in record.features.

## Задание 2
1. Ошибка: Некорректный расчет GC для пустых последовательностей.
- Исправление: Добавление проверки if len(seq) > 0.
2. Ошибка: Неправильная сортировка из-за строкового сравнения GC.
- Исправление: Преобразование GC в float перед сортировкой.

## Задание 3
1. Ошибка: Трансляция некодирующих областей.
- Исправление: Извлечение только CDS-фрагментов.
2. Ошибка: Игнорирование рамки считывания.
- Исправление: Учет frame в feature.qualifiers.get("transl_table").

### Выводы
- Успешно создан объединенный GenBank-файл с 10+ CDS.
- Реализован расчет и сортировка GC-составов с выводом в GUI.
- Получены белковые последовательности через трансляцию CDS.
