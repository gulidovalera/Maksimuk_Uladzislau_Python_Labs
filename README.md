# Лабораторные работы по Python

## Файлы с кодом
- [Лаба-1 в1.py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/Лаба-1%20в1.py) - Лабораторная работа 1
- [лаба2 (1).py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/лаба2%20(1).py) - Лабораторная работа 2
- [В3задание2(2).py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/%23В3задание2(2).py), [В1задание1(2).py](https://github.com/gulidovalera/laba/blob/лаба-1/В1задание1(2).py) - Лабораторная работа 3
- [лаба4_В3 биопитон с окном для файла.py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/лаба4_В3%20биопитон%20с%20окном%20для%20файла.py) - Лабораторная работа 4

---

## Лабораторная работа 1: "Подсчёт точечных мутаций методом Хэмминга для триплетов ДНК"

### Цель работы
Исследование точечных мутаций в последовательностях ДНК путём вычисления расстояния Хэмминга между триплетами (группами из трёх нуклеотидов) двух гомологичных цепей ДНК. Разработка программных реализаций на Python для решения данной задачи.

## Задачи
1. Реализовать функцию для вычисления расстояния Хэмминга между триплетами двух последовательностей ДНК
2. Создать объектно-ориентированную версию программы с использованием класса
3. Обеспечить корректную обработку входных данных:
  - Проверка равенства длин последовательностей
  - Валидация допустимых символов (A, T, G, C)
4. Протестировать программу на примере из условия задачи

### Инструменты и алгоритмы
 Язык программирования: Python.
 Стандартные библиотеки Python (без дополнительных зависимостей)
 Функциональная реализация:
 - Разбиение последовательностей на триплеты с шагом 3
 - Поэлементное сравнение нуклеотидов в соответствующих триплетах
 - Подсчёт количества несовпадений
Объектно-ориентированная реализация:
 - Класс HammingTripletCalculator, инкапсулирующий:
  - Хранение последовательностей
  - Ввод данных
  - Вычисление расстояния Хэмминга
  - Использование метода zip для попарного сравнения символов
Структура программы:
 ```python
# Функциональный подход
def hamming_distance_triplets(s, t):
    # ... реализация ...

# Объектно-ориентированный подход
class HammingTripletCalculator:
    def __init__(self): ...
    def input_sequence(self): ...
    def calculate_distance(self): ...
 ```

### Ошибки и исправления
Проблема: Отсутствие проверки длины последовательностей
Симптомы: Неверные результаты при неравных длинах
Решение: Добавить проверку if len(s) != len(t): raise ValueError()

Проблема: Нет валидации входных символов
Симптомы: Возможны ошибки при вводе недопустимых символов
Решение: Добавить проверку символов на принадлежность к {'A', 'T', 'G', 'C'}

Проблема: Неполные триплеты в конце последовательности
Симптомы: Потеря данных при длине не кратной 3
Решение: Обрабатывать остаток как отдельный триплет или требовать длину, кратную 3

Проблема: Чувствительность к регистру
Симптомы: Разные результаты для 'A' и 'a'
Решение: Приводить последовательности к верхнему регистру

### Выводы
Разработаны две реализации алгоритма подсчёта расстояния Хэмминга для триплетов ДНК:
 - Процедурная (функциональная) версия
 - Объектно-ориентированная версия

Программа успешно решает поставленную задачу:
 - Корректно вычисляет количество точечных мутаций
 - Работает с последовательностями длиной до 1000 символов
 - Обрабатывает триплеты как отдельные блоки сравнения

Объектно-ориентированный подход показал следующие преимущества:
 - Лучшая структурированность кода
 - Инкапсуляция данных и методов
 - Возможность легкого расширения функциональности

Практическое применение:
 - Анализ мутаций в кодирующих областях ДНК
 - Сравнение гомологичных последовательностей
 - Исследование эволюционных расстояний между видами

Дальнейшие улучшения могут включать:
 - Визуализацию различий между последовательностями
 - Статистический анализ распределения мутаций
 - Поддержку других типов нуклеиновых кислот (РНК)
 - Расширение для работы с аминокислотными последовательностями

Программа демонстрирует эффективный подход к анализу точечных мутаций и может служить основой для более сложных биоинформатических инструментов.

---

## Лабораторная работа 2: "Работа с файлами в Python. Вычисление GC-состава"

### Цель работы
Разработать программу для анализа последовательностей ДНК в формате FASTA с целью определения GC-состава (доли гуанина (G) и цитозина (C)) и выявления последовательности с максимальным значением этого показателя.

### Задачи
1. Обработка входных данных:
   - Чтение последовательностей ДНК в формате FASTA.
   - Разделение идентификаторов (строки с >) и самих последовательностей.
2. Вычисление GC-состава:
   - Подсчёт количества символов G и C в каждой последовательности.
   - Расчёт доли GC-пар от общей длины последовательности (в процентах).
3. Анализ результатов:
   - Определение последовательности с наибольшим GC-составом.
   - Вывод результатов в заданном формате.

### Инструменты и алгоритмы
- Язык программирования: Python.
- Структуры данных:
  - Словарь sequences для хранения пар идентификатор: последовательность.
- Алгоритмы:
  - Чтение данных: Построчная обработка ввода с проверкой на начало идентификатора (>) или последовательности.
  - Расчёт GC-состава: Формула:
    ```python
    GC_content = (count('G') + count('C')) / len(sequence) * 100
    ```
  - Поиск максимума: Итерация по словарю с сравнением значений.
  - Форматирование вывода:
    - Округление результатов до двух знаков после запятой (:.2f).

### Ошибки и исправления
1. Ошибка: Некорректная обработка многострочных последовательностей.
   - Исправление: Добавление условия для конкатенации строк последовательности к текущему идентификатору.
2. Ошибка: Невнимание к регистру символов (например, g vs G).
   - Исправление: Предполагается, что входные данные в верхнем регистре (по условию задачи).
3. Ошибка: Отсутствие проверки на пустые последовательности.
   - Исправление: В данной задаче не требуется, так как входные данные гарантированно валидны.
     
### Выводы
- Успешная обработка до 10 последовательностей
- Применение для сравнения геномов и идентификации ДНК

---

## Лабораторная работа 3: "Представление данных в Python"

### Цель работы
Освоить методы визуализации данных в Python с использованием библиотеки matplotlib:
1. Построение диаграммы рассеяния для анализа взаимосвязи между признаками и их классификации.
2. Построение графиков временных рядов для изучения динамики изменения данных.

### Задания
## Задание 1. Построение диаграммы рассеяния
1. Загрузить данные (набор Iris).
2. Выбрать два признака для осей X и Y.
3. Визуализировать данные с цветовой дифференциацией по классам.
4. Добавить подписи, легенду и сетку для улучшения читаемости.

## Задание 2. Построение графика временных рядов
1. Загрузить данные (уровень CO₂).
2. Выбрать временной промежуток для анализа.
3. Построить график динамики изменений.
4. Настроить оформление (заголовок, подписи осей, сетку).

### Инструменты
- `matplotlib.pyplot` для визуализации
- `sklearn.datasets` для Iris
- `statsmodels.api` для CO₂

 Библиотеки:
- `matplotlib.pyplot` для визуализации.
- `sklearn.datasets` для загрузки данных Iris.
-  `statsmodels.api` для CO₂
 Алгоритм задание 1:
- Загрузка данных: load_iris().
- Разделение данных по классам: self.y == label.
- Построение scatter-графика: plt.scatter().
- Настройка оформления: plt.xlabel(), plt.legend().

 Алгоритм задание 2:
- Загрузка данных: sm.datasets.co2.load_pandas().
- Фильтрация по временному диапазону: self.co2[start_date:end_date].
- Построение линейного графика: plt.plot().
- Настройка оформления: plt.title(), plt.grid().
  
### Ошибки и исправления
## Задание 1
1. Ошибка: Неверный выбор индексов признаков.
- Пример: Использование индексов 5 и 6 (выход за границы).
- Исправление: Проверка диапазона (0 ≤ index < 4).
2. Ошибка: Наложение подписей точек.
- Пример: Перекрывающиеся метки классов.
- Исправление: Увеличение размера графика (figsize=(12, 8)).
3. Ошибка: Неправильные цвета для классов.
- Пример: Повторение цветов (['red', 'red', 'blue']).
- Исправление: Уникальные цвета для каждого класса.

## Задание 2
1. Ошибка: Неверный формат дат.
- Пример: start_date='1958' (отсутствует месяц и день).
- Исправление: Указание полной даты ('1958-01-01').
2. Ошибка: Пропущенные данные в ряду.
- Пример: Пробелы в данных CO₂.
- Исправление: Интерполяция (self.co2.interpolate()).
3. Ошибка: Слишком плотная сетка дат.
- Пример: Нечитаемые подписи на оси X.
- Исправление: Настройка частоты меток (plt.xticks(rotation=45)).

### Выводы
1. Результаты задания 1:
- Диаграмма рассеяния наглядно показывает кластеры видов ирисов по выбранным признакам.
- Цветовое разделение упрощает интерпретацию классов.
2. Результаты задания 2:
- График временного ряда CO₂ демонстрирует устойчивый рост концентрации за выбранный период.
- Настройка оформления улучшает восприятие динамики.
3. Общие выводы:
- Библиотека matplotlib предоставляет гибкие инструменты для визуализации данных.
- Важно учитывать потенциальные ошибки (формат данных, наложение графиков) для корректного отображения.

---

## Лабораторная работа 4: "Работа с BioPython"

### Цель работы
Обработка биологических данных в формате GenBank:
1. Объединение файлов
2. Анализ GC-состава
3. Трансляция кодирующих областей

### Задачи
## Задание 1. Формирование исходного файла
1. Загрузить по 5 CDS-последовательностей для двух видов с NCBI в формате GenBank.
2. Объединить записи в единый файл средствами BioPython.
3. Проверить, что итоговый файл содержит не менее 10 CDS.

## Задание 2. Анализ GC-составов
1. Прочитать файл GenBank, извлечь последовательности.
2. Вычислить GC-состав для каждой последовательности.
3. Отсортировать последовательности по возрастанию GC-состава.
4. Вывести результаты с указанием ID, описания и значения GC.

## Задание 3. Трансляция
1. Извлечь кодирующие области (CDS) из файла GenBank.
2. Транслировать нуклеотидные последовательности в аминокислотные.
3. Вывести белковые последовательности с указанием исходных CDS.

### Инструменты
## Задание 1
 Библиотеки:
- `Bio.SeqIO` для чтения/записи GenBank-файлов.
 Алгоритм:
- Скачивание данных с NCBI (вручную).
- Объединение файлов через SeqIO.write(records, "output.gb", "genbank").

## Задание 2
 Библиотеки:
- `Bio.SeqIO` для парсинга GenBank.
- `tkinter` для GUI.
 Алгоритм:
- Чтение файла: SeqIO.parse(filename, "genbank").
- Расчет GC-состава:
 ```python
 gc_content = (seq.count("G") + seq.count("C")) / len(seq)
 ```
- Сортировка: sorted(sequences, key=lambda x: x[2]).

## Задание 3
 Библиотеки:
- `Bio.Seq` для трансляции.
 Алгоритм:
- Извлечение CDS из записей GenBank.
- Трансляция: seq.translate(table="стандартный_код").

### Ошибки и исправления
## Задание 1
1. Ошибка: Несовместимость форматов файлов от разных видов.
- Исправление: Проверка и конвертация в единый формат GenBank.
2. Ошибка: Отсутствие CDS в некоторых записях.
- Исправление: Фильтрация записей с if "CDS" in record.features.

## Задание 2
1. Ошибка: Некорректный расчет GC для пустых последовательностей.
- Исправление: Добавление проверки if len(seq) > 0.
2. Ошибка: Неправильная сортировка из-за строкового сравнения GC.
- Исправление: Преобразование GC в float перед сортировкой.

## Задание 3
1. Ошибка: Трансляция некодирующих областей.
- Исправление: Извлечение только CDS-фрагментов.
2. Ошибка: Игнорирование рамки считывания.
- Исправление: Учет frame в feature.qualifiers.get("transl_table").

### Выводы
- Успешно создан объединенный GenBank-файл с 10+ CDS.
- Реализован расчет и сортировка GC-составов с выводом в GUI.
- Получены белковые последовательности через трансляцию CDS.
